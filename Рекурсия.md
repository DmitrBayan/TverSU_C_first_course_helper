# Рекурсивные функции

**Рекурсия** — это метод программирования, при котором функция вызывает саму себя для решения подзадачи. 

**Рекурсивные функции** — это функции, которые для выполнения задачи используют собственные вызовы. Это мощный инструмент, который может упростить решение многих задач, таких как работа с деревьями, графами, и математическими задачами (например, вычисление факториала или чисел Фибоначчи).

## Как работает рекурсия?

Каждый вызов рекурсивной функции создает новый уровень выполнения (stack frame) с собственным контекстом, включая параметры и локальные переменные. Когда функция завершает работу, текущий уровень выполнения удаляется, и программа возвращается к предыдущему уровню. 

Рекурсивная функция должна содержать два ключевых элемента:
1. **Базовый случай (условие завершения)** — условие, при котором рекурсия заканчивается.
2. **Рекурсивный вызов** — шаг, который сокращает задачу и приближает её к базовому случаю.

## Пример рекурсивной функции

Рассмотрим простую рекурсивную функцию для вычисления факториала числа.

### Синтаксис:
```C
int factorial(int n) 
{
    if (n == 0) // Базовый случай: факториал 0 равен 1
    {
        return 1;
    }
    else 
    {
        return n * factorial(n - 1); // Рекурсивный вызов
    }
}
```
Пояснение:
- **Базовый случай**: Если `n` равно 0, функция возвращает 1, так как факториал 0 по определению равен 1.
- **Рекурсивный вызов**: Если `n` больше 0, функция вызывает саму себя с аргументом `n - 1`, умножая результат на `n`.

Если пройти каждый шаг по отдельности, можно представить это в виде схемы:
```C
factorial(5) = 5 * factorial(4)
                   factorial(4) = 4 * factorial(3)
                                      factorial(3) = 3 * factorial(2)
                                                         factorial(2) = 2 * factorial(1)
                                                                            factorial(1) = 1 * factorial(0)
                                                                                               factorial(0) = 1
```

## Важные моменты при работе с рекурсией
1. **Базовый случай обязателен**: 
    Без базового случая функция будет вызывать саму себя бесконечно, что приведет к переполнению стека (stack overflow).

    Пример бесконечной рекурсии (неправильный код):
    ```C
    int infiniteRecursion(int n) 
    {
        return infiniteRecursion(n - 1); // Нет базового случая, рекурсия будет продолжаться бесконечно
    }
    ```
2. **Рекурсия должна уменьшать задачу**:
    Каждый рекурсивный вызов должен приближать решение задачи к базовому случаю. В противном случае функция никогда не завершится.
3. **Нагрузка на память**:
    Каждый вызов рекурсивной функции занимает память в стеке. Это может привести к переполнению стека при большом количестве рекурсивных вызовов. Для больших задач стоит рассмотреть использование циклов или оптимизировать рекурсию.
4. **Хвостовая рекурсия**: 
    Это особый вид рекурсии, при котором рекурсивный вызов является последней операцией в функции. Некоторые компиляторы оптимизируют хвостовую рекурсию, что уменьшает нагрузку на стек. (для более детальной информации смотреть ниже)
5. **Рекурсивные функции vs циклы**:
    Многие задачи, решаемые с помощью рекурсии, можно решить с помощью циклов, что будет более эффективно по памяти. Тем не менее, рекурсия может сделать код более элегантным и проще для понимания.





## Хвостовая рекурсия
**Хвостовая рекурсия (tail recursion)** — это особый вид рекурсии, при котором рекурсивный вызов является последней операцией в функции. Это важное понятие в оптимизации рекурсивных алгоритмов, так как компиляторы и интерпретаторы могут применять оптимизацию хвостовой рекурсии (tail call optimization, TCO), что позволяет избегать создания новых стековых фреймов для каждого рекурсивного вызова.

### Как работает хвостовая рекурсия?
В обычной рекурсии после того, как рекурсивная функция возвращает результат, программа должна продолжить выполнение операций, которые были отложены до возврата результата. В хвостовой рекурсии результат рекурсивного вызова сразу же возвращается как итог работы функции, и никакие дополнительные операции после этого не выполняются.

#### Пример обычной рекурсии
Пример рекурсивной функции для вычисления факториала числа:
```C
int factorial(int n) 
{
    if (n == 0)
    {
        return 1;
    }
    else 
    {
        return n * factorial(n - 1); // После возвращения нужно умножить на n
    }
}
```
Здесь после возвращения результата `factorial(n - 1)` функция должна умножить его на `n`. Это означает, что каждый вызов рекурсивной функции требует сохранения текущего состояния (текущего значения `n` и операции умножения) в стеке до завершения всех рекурсивных вызовов.

#### Пример хвостовой рекурсии
Теперь посмотрим на хвостовую рекурсию для вычисления факториала:
```C
int tailFactorial(int n, int accumulator) 
{
    if (n == 0)
    {
        return accumulator; // Возвращаем накопленный результат
    }
    else 
    {
        return tailFactorial(n - 1, n * accumulator); // Рекурсивный вызов является последней операцией
    }
}

int factorial(int n)
{
    return tailFactorial(n, 1); // Запускаем рекурсивный процесс с аккумулятором, равным 1
}
```
В этом примере:
- Мы добавили дополнительный параметр `accumulator` (аккумулятор), который накапливает промежуточные результаты.
- В каждом рекурсивном вызове значение `n` уменьшается на 1, а `accumulator` умножается на текущее значение `n`.
- Как только `n` достигает 0, возвращается накопленный результат.

#### Отличие хвостовой рекурсии
Ключевая особенность хвостовой рекурсии заключается в том, что рекурсивный вызов является последней операцией, которую выполняет функция. После вызова не требуется никаких дополнительных вычислений, поэтому нет необходимости хранить текущее состояние в стеке.

#### Оптимизация хвостовой рекурсии (TCO)
Многие компиляторы и интерпретаторы могут оптимизировать хвостовую рекурсию, заменяя рекурсивный вызов на обычную итерацию. Это означает, что при оптимизированной хвостовой рекурсии не создается новый стековый фрейм, и вместо этого происходит "перезапись" текущего фрейма функции новыми параметрами.

Без оптимизации каждая рекурсия создает новый уровень в стеке вызовов, что может привести к переполнению стека при больших значениях. Оптимизация хвостовой рекурсии предотвращает переполнение стека, так как стековые фреймы не накапливаются.
